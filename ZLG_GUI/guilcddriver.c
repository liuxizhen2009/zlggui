// /****************************************************************************************
// * 文件名：LCDDRIVE.C
// * 功能：图形液晶240*128驱动(型号为SMG240128A)。32K显示存，0000H-7FFFH地址。显示是横向字节，高位
// *      在前。
// * 说明：图形液晶采用T6963C为LCD控制芯片，内带负压产生器，单5伏供电，并行接口(使用LPC2210驱动)。
// * 硬件连接： D0--D7  <===>  D0--D7
// *           /WR     <===>  nWE
// *           /RD     <===>  nOE
// *           /CE     <===>  nCS3_1
// *           C/D     <===>  A1
// *
// *           /RST    <===>  VCC
// ****************************************************************************************/
 #include "config.h"

 TCOLOR  	gui_disp_buf[GUI_LCM_YMAX/8][GUI_LCM_XMAX];				// 声明GUI显示缓冲区

// /* 定义LCM地址 */
// //#define  TG240128_COM    	(*((volatile unsigned short *) 0x83000002))
// //#define  TG240128_DAT    	(*((volatile unsigned short *) 0x83000000))
// 	

// /***********************************************************************
// * 名称：LCD_WriteCommand()
// * 功能：写命令子程序。(发送命令前，不检查液晶模块的状态)
// * 入口参数：command  	要写入LCM的命令字
// * 出口参数：无
// * 说明：函数会设置LCM数据总线为输出方式
// ***********************************************************************/
// //#define   LCD_WriteCommand(command)  TG240128_COM = (uint16)command


// /***********************************************************************
// * 名称：LCD_WriteData()
// * 功能：写数据子程序。(发送数据前，不检查液晶模块的状态)
// * 入口参数：dat  	要写入LCM的数据
// * 出口参数：无
// * 说明：函数会设置LCM数据总线为输出方式
// ***********************************************************************/
// //#define  LCD_WriteData(dat)  TG240128_DAT = (uint16)dat



// /***********************************************************************
// * 名称：LCD_ReadState()
// * 功能：读取状态字子程序。
// * 入口参数：无
// * 出口参数：返回值即为读出的状态字
// * 说明：函数会设置LCM数据总线为输入方式
// ***********************************************************************/
// //#define  LCD_ReadState()	TG240128_COM


// /***********************************************************************
// * 名称：LCD_ReadData()
// * 功能：读取数据子程序。
// * 入口参数：无
// * 出口参数：返回值即为读出的数据
// * 说明：函数会设置LCM数据总线为输入方式
// ***********************************************************************/
// //#define  LCD_ReadData()		TG240128_DAT


// /* 以下为LCM的驱动层，主要负责发送T6963的各种命令，提供设置显示地址等功能，在发送命令前会检测其状态字。带参数命令模式：先参数，后命令；操作模式：先命令，后数据 */

// /* T6963C 命令定义 */
// // #define  LCD_CUR_POS		0x21						/* 光标位置设置(只有设置到有效显示地址并打开显示时才看到) */
// // #define  LCD_CGR_POS		0x22						/* CGRAM偏置地址设置(可以增加自已的符号) */
// // #define  LCD_ADR_POS		0x24						/* 地址指针位置(设置读写操作指针) */

// // #define  LCD_TXT_STP		0x40						/* 文本区首址(从此地址开始向屏幕左上角显示字符) */
// // #define  LCD_TXT_WID		0x41						/* 文本区宽度(设置显示宽度，N/6或N/8，其中N为x轴的点数) */
// // #define  LCD_GRH_STP		0x42						/* 图形区首址(从此地址开始向屏幕左上角显示点) */
// // #define  LCD_GRH_WID		0x43						/* 图形区宽度(设置显示宽度，N/6或N/8，其中N为x轴的点数) */

// // #define  LCD_MOD_OR			0x80						/* 显示方式：逻辑或 */
// // #define  LCD_MOD_XOR		0x81						/* 显示方式：逻辑异或 */
// // #define  LCD_MOD_AND		0x82						/* 显示方式：逻辑与 */
// // #define  LCD_MOD_TCH		0x83						/* 显示方式：文本特征 */

// // #define  LCD_DIS_SW			0x90						/* 显示开关：D0=1/0，光标闪烁启用/禁用 */
// // 														/* 			D1=1/0，光标显示启用/禁用 */
// // 														/* 			D2=1/0，文本显示启用/禁用(打开后再使用) */
// // 														/* 			D3=1/0，图形显示启用/禁用(打开后再使用) */
// // 														
// // #define  LCD_CUR_SHP		0xA0						/* 光标形状选择：0xA0-0xA7表示光标占的行数 */

// // #define  LCD_AUT_WR			0xB0						/* 自动写设置 */
// // #define  LCD_AUT_RD			0xB1						/* 自动读设置 */
// // #define  LCD_AUT_OVR		0xB2						/* 自动读/写结束 */

// // #define  LCD_INC_WR			0xC0						/* 数据一次写，地址加1 */
// // #define  LCD_INC_RD			0xC1						/* 数据一次读，地址加1 */
// // #define  LCD_DEC_WR			0xC2						/* 数据一次写，地址减1 */
// // #define  LCD_DEC_RD			0xC3						/* 数据一次读，地址减1 */
// // #define  LCD_NOC_WR			0xC4						/* 数据一次写，地址不变 */
// // #define  LCD_NOC_RD			0xC5						/* 数据一次读，地址不变 */

// // #define  LCD_SCN_RD			0xE0						/* 屏读 */

// // #define  LCD_SCN_CP			0xE8						/* 屏拷贝 */

// // #define  LCD_BIT_OP			0xF0						/* 位操作：D0-D2--定义D0-D7位，D3--1为置位，0为清除 */


// // /***********************************************************************
// // * 名称：LCD_TestStaBit01()
// // * 功能：判断读写指令和读写数据是否允许。
// // * 入口参数：无
// // * 出口参数：返回0表示禁止，否则表示允许
// // ***********************************************************************/
// // uint8  LCD_TestStaBit01(void)
// // {  uint8 i;

// //    for(i=100; i>0; i--)
// //    {  if( (LCD_ReadState()&0x03)==0x03 ) break;
// //    }
// //    
// //    return(i);
// // }


// // /***********************************************************************
// // * 名称：LCD_TestStaBit3()
// // * 功能：数据自动写状态是否允许。
// // * 入口参数：无
// // * 出口参数：返回0表示禁止，否则表示允许
// // ***********************************************************************/
// // uint8  LCD_TestStaBit3(void)
// // {  uint8 i;

// //    for(i=100; i>0; i--)
// //    {  if( (LCD_ReadState()&0x08)==0x08 ) break;
// //    }
// //    
// //    return(i);
// // }


// // /***********************************************************************
// // * 名称：LCD_WriteTCommand1()
// // * 功能：写无参数命令子程序。会先判断LCM状态字。
// // * 入口参数：command  		要写入LCM的命令字
// // * 出口参数：操作出错返回0，否则返回1
// // ***********************************************************************/
// // uint8  LCD_WriteTCommand1(uint8 command)
// // {  if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteCommand(command);		// 发送命令字
// //    
// //    return(1);
// // }


// // /***********************************************************************
// // * 名称：LCD_WriteTCommand3()
// // * 功能：写双参数命令子程序。会先判断LCM状态字。
// // * 入口参数：command  	要写入LCM的命令字
// // *          dat1		参数1
// // *          dat2		参数2
// // * 出口参数：操作出错返回0，否则返回1
// // * 说明：先发送两字节参数据数据，再发送命令字
// // ***********************************************************************/
// // uint8  LCD_WriteTCommand3(uint8 command, uint8 dat1, uint8 dat2)
// // {  if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteData(dat1);				// 发送数据1
// //    
// //    if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteData(dat2);				// 发送数据2
// //    
// //    if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteCommand(command);		// 发送命令字
// //    
// //    return(1);
// // }


// // /***********************************************************************
// // * 名称：LCD_WriteTCommand2()
// // * 功能：写单参数命令子程序。会先判断LCM状态字。
// // * 入口参数：command  	要写入LCM的命令字
// // *          dat1		参数1
// // * 出口参数：操作出错返回0，否则返回1
// // * 说明：先发送参数据数据，再发送命令字
// // ***********************************************************************/
// // uint8  LCD_WriteTCommand2(uint8 command, uint8 dat1)
// // {  if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteData(dat1);				// 发送数据1
// //    
// //    if( LCD_TestStaBit01()==0 ) return(0);
// //    LCD_WriteCommand(command);		// 发送命令字
// //    
// //    return(1);
// // }


// // /***********************************************************************
// // * 名称：LCD_WriteTData1()
// // * 功能：写1字节数据子程序。会先判断状态字。
// // * 入口参数：dat  		要写入LCM的数据
// // * 出口参数：操作出错返回0，否则返回1
// // ***********************************************************************/
// // uint8  LCD_WriteTData1(uint8 dat)
// // {  if( LCD_TestStaBit3()==0 ) return(0);
// //    LCD_WriteData(dat);				// 发送命令字
// //    
// //    return(1);
// // }


// // /* 以下为LCM的用户接口层，主要负责解释用户命令，并发送到LCM，为用户编程提供接口 */


/***********************************************************************
* 名称：LCD_Initialize()
* 功能：LCM初始化，将LCM初始化为纯图形模式，显示起始地址为0x0000，。
* 入口参数：无
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/
void Initial_Lcd();
void  LCD_Initialize(void)
{  
	Initial_Lcd();
}


/***********************************************************************
* 名称：LCD_FillAll()
* 功能：LCD填充。以图形方式进行填充，起始地址为0x0000。
* 入口参数：dat		要填充的数据
* 出口参数：无
***********************************************************************/
void FullAll(unsigned char dat) ;
void  LCD_FillAll(uint8 dat)
{  
	FullAll(dat) ;
}


/****************************************************************************
* 名称：LCD_UpdatePoint()
* 功能：在指定位置上画点，刷新某一点。
* 入口参数： x		指定点所在列的位置
*           y		指定点所在行的位置
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/

/*
Transfer_command(0xb0+i);   //set page address,
Transfer_command((0x10)|(j>>4));//刘西振这两行是控制列地址的。
Transfer_command((0x00)|(j&0x0f));//
*/
void  LCD_UpdatePoint(uint32 x, uint32 y)//刘西振需要移植
{  uint32  addr; 
 
   /* 找出目标地址 */
   addr = (y>>3)*(GUI_LCM_XMAX) + (x);
   //LCD_WriteTCommand3(LCD_ADR_POS, addr&0xFF, addr>>8);	// 置地址指针
   //首先根据x，和y设置列地址和页地址	
	Transfer_command(0xb0+(y>>3));   	//set page address,
	Transfer_command((0x10)|(x>>4));	//刘西振这两行是控制列地址的。
	Transfer_command((0x00)|(x&0x0f));//
   /* 输出数据 */
   //LCD_WriteTCommand2(LCD_INC_WR, gui_disp_buf[y][x>>3]);
	Transfer_data(gui_disp_buf[y>>3][x]);  
}



// /****************************************************************************
// *                    与LCM相关的GUI接口函数



// ****************************************************************************/


/****************************************************************************
* 名称：GUI_FillSCR()
* 功能：全屏填充。直接使用数据填充显示缓冲区。
* 入口参数：dat		填充的数据(对于黑白色LCM，为0的点灭，为1的点显示)
* 出口参数：无
****************************************************************************/
void  GUI_FillSCR(uint8 dat)
{  uint32  i, j;

    for(i=0; i<GUI_LCM_YMAX/8; i++)		// 历遍所有行
   {  for(j=0; j<GUI_LCM_XMAX; j++)	// 历遍所有行
      {  gui_disp_buf[i][j] = dat;		// 填充数据
	  }
   }
   
   /* 填充LCM */
   LCD_FillAll(dat);
}


/****************************************************************************
* 名称：GUI_Initialize()
* 功能：初始化GUI，包括初始化显示缓冲区，初始化LCM并清屏。
* 入口参数：无
* 出口参数：无
****************************************************************************/
void  GUI_Initialize(void)
{  
	int i,j;
	for(i=0;i<(GUI_LCM_YMAX>>3);i++){
		for(j=0;j<GUI_LCM_XMAX;j++){
			gui_disp_buf[i][j]=0;
		};
	}		
	LCD_Initialize();					// 初始化LCM模块工作模式，纯图形模式
  GUI_FillSCR(0x00);					// 初始化缓冲区为0x00，并输出屏幕(清屏)
} 


/****************************************************************************
* 名称：GUI_ClearSCR()
* 功能：清屏。
* 入口参数：无
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_ClearSCR(void)
{  GUI_FillSCR(0x00);
}


 uint8 const  DCB_HEX_TAB[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

// /****************************************************************************
// * 名称：GUI_Point()
// * 功能：在指定位置上画点。
// * 入口参数： x		指定点所在列的位置
// *           y		指定点所在行的位置
// *           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
// * 出口参数：返回值为1时表示操作成功，为0时表示操作失败。(操作失败原因是指定地址超出有
// *          效范围)
// * 说明：用户根据LCM的实际情况编写此函数。对于单色，只有一个位有效，则要使用左移的方法
// *      实现point_dat = (point_dat&MASK_TAB [i]) | (color<<n)，其它位数的一样
// *      处理。
// ****************************************************************************/
 uint8  GUI_Point(uint32 x, uint32 y, TCOLOR color)
 {  /* 参数过滤 */
   if(x>=GUI_LCM_XMAX) return(0);
   if(y>=GUI_LCM_YMAX) return(0);
   
   /* 设置缓冲区相应的点 */
   if( (color&0x01) != 0 ){ 
		 gui_disp_buf[y>>3][x]=(gui_disp_buf[y>>3][x])|DCB_HEX_TAB[y&0x07];
		 }
   else{  
		 gui_disp_buf[y>>3][x]=(gui_disp_buf[y>>3][x])&(~DCB_HEX_TAB[y&0x07]);
		 }
   /* 刷新显示 */
   LCD_UpdatePoint(x, y);
    return(1);
 }

// /****************************************************************************
// * 名称：GUI_ReadPoint()
// * 功能：读取指定点的颜色。
// * 入口参数：x			指定点所在列的位置
// *          y		指定点所在行的位置
// *          ret		保存颜色值的指针
// * 出口参数：返回0时表示指定地址超出有效范围。
// * 说明：对于单色，设置ret的d0位为1或0，4级灰度则为d0、d1有效，8位RGB则d0--d7有效，
// *      RGB结构则R、G、B变量有效。
// ****************************************************************************/
 int  GUI_ReadPoint(uint32 x, uint32 y, TCOLOR *ret)
 {  TCOLOR  bak;

   /* 参数过滤 */
   if(x>=GUI_LCM_XMAX) return(0);
   if(y>=GUI_LCM_YMAX) return(0);  
   /* 取得该点颜色(用户自行更改) */ 
   bak = gui_disp_buf[y>>3][x];
   if( (bak&DCB_HEX_TAB[y&0x07])!=0 ) {
		*ret = 1;
		}else {
		*ret = 0;}
   return(1);
 }


// /****************************************************************************
// * 名称：GUI_RLine()
// * 功能：画垂直线。
// * 入口参数： x0		垂直线起点所在列的位置
// *           y0		垂直线起点所在行的位置
// *           y1      垂直线终点所在行的位置
// *           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
// * 出口参数：无
// * 说明：操作失败原因是指定地址超出缓冲区范围。
// ****************************************************************************/
 void  GUI_RLine(uint32 x0, uint32 y0, uint32 y1, uint8 color) 
 {  uint32  bak;

   if(y0>y1) 						// 对x0、x1大小进行排列，以便画图
   {  bak = y1;
      y1 = y0;
      y0 = bak;
   }
   if(y0==y1)
   {  GUI_Point(x0, y0, color);
      return;
   }
   
   do
   {  /* 设置相应的点为1 */
      if(0!=color){ 
				gui_disp_buf[y0>>3][x0] |= DCB_HEX_TAB[y0&0x07];
			}else{
				gui_disp_buf[y0>>3][x0] &= (~DCB_HEX_TAB[y0&0x07]);
			}
      /* 刷新显示(一次刷新一字节) */
      if( (y0&0x07)==0x07 ){
				LCD_UpdatePoint(x0, y0);
			}      
      y0++;
   }while(y1>y0);
   
   /* 对最后一点显示操作 */
   if(0!=color) gui_disp_buf[y0>>3][x0] |= DCB_HEX_TAB[y0&0x07];
      else  gui_disp_buf[y0>>3][x0] &= (~DCB_HEX_TAB[y0&0x07]);
   LCD_UpdatePoint(x0, y0);
 }



 
 // /****************************************************************************
// * 名称：GUI_HLine()
// * 功能：画水平线。
// * 入口参数： x0		水平线起点所在列的位置
// *           y0		水平线起点所在行的位置
// *           x1      水平线终点所在列的位置
// *           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
// * 出口参数：无
// * 说明：操作失败原因是指定地址超出缓冲区范围。
// ****************************************************************************/
 void  GUI_HLine(uint32 x0, uint32 y0, uint32 x1, uint8 color) 
 {  uint32  bak;

   if(x0>x1) 						// 对y0、y1大小进行排列，以便画图
   {  bak = x1;
      x1 = x0;
      x0 = bak;
   }
   if(x0==x1)
   {  GUI_Point(x0, y0, color);
      return;
   }
   
   do
   {  GUI_Point(x0, y0, color);		// 逐点显示，描出垂直线
      x0++;
   }while(x1>x0);
   GUI_Point(x0, y0, color);	
 }

 
  // /****************************************************************************
// * 名称：GUI_HLine()
// * 功能：画水平线。
// * 入口参数： x0		水平线起点所在列的位置
// *           y0		水平线起点所在行的位置
// *           x1      水平线终点所在列的位置
// *           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
// * 出口参数：无
// * 说明：操作失败原因是指定地址超出缓冲区范围。
// ****************************************************************************/
 void  GUI_FullRec(uint32 x0, uint32 y0, uint32 x1,uint32 y1, uint8 color) 
 {  uint32  bak;

   if(x0>=x1) 						// 对y0、y1大小进行排列，以便画图
   { return;   }
   if(y0>=y1){return;}
   //gui_disp_buf[]
   do
   {  GUI_Point(x0, y0, color);		// 逐点显示，描出垂直线
      x0++;
   }while(x1>x0);
   GUI_Point(x0, y0, color);	
 }




